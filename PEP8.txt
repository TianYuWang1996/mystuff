PEP 8 -- Style Guide for Python Code
PEP 8 Python代码风格的指导：

Introduction 介绍：
============

This document gives coding conventions for the Python code comprising
the standard library in the main Python distribution.  
Please see the companion informational PEP describing style guidelines 
for the C code in the C implementation of Python [1]_.
本文给出了Python主要发行版本中校准库的python代码的编程惯例。
请查阅附带的信息性PEP，它描述了C代码在Python中实现的代码风格。
This document and PEP 257 (Docstring Conventions) were adapted from
Guido's original Python Style Guide essay, with some additions from
Barry's style guide [2]_.
本文和PEP257（文档字符串约定）改编自Guido的原始Python风格指导文章，
并从Barry的风格指导中添加了一些内容。
This style guide evolves over time as additional conventions are
identified and past conventions are rendered obsolete by changes in
the language itself.
这份风格指导随着时间不断增添附加约定，过去的约定也会随着语言本身的改变而过时。
Many projects have their own coding style guidelines. In the event of any
conflicts, such project-specific guides take precedence for that project.
很多项目都有自己的编码风格指南。
如有冲突，特定的风格将优于本文所提供的风格。

A Foolish Consistency is the Hobgoblin of Little Minds 
       "不要墨守成规。"                        ——Ralph Waldo Emerson
======================================================

One of Guido's key insights is that code is read much more often than
it is written.  
The guidelines provided here are intended to improve the readability 
of code and make it consistent across the wide spectrum of Python code.  
As PEP 20 says, "Readability counts".
Guido的认为：代码的阅读频率要远高于它的编写频率。
这里提供的指导方针旨在提高代码的可读性，并使其在各种各样的Python代码中保持一致。
正如PEP20所说的：可读性很重要。
A style guide is about consistency.  
Consistency with this style guide is important.  
Consistency within a project is more important.
Consistency within one module or function is the most important.
风格指南是包括一致性的。
与风格指南一致
项目内部一致
模块和函数内部一致
However, know when to be inconsistent -- 
sometimes style guide recommendations just aren't applicable.  
When in doubt, use your best judgment.  
look at other examples and decide what looks best.  
And don't hesitate to ask!
当出现不一致情况时：
有时，风格指南的建议并不适用。
有疑问时，最好运用你自己的判断力。
看看其他例子，问问其他人是怎么做的。
In particular: do not break backwards compatibility just to comply with
this PEP!
注意：不要为了遵守PEP而破坏向后兼容性。
Some other good reasons to ignore a particular guideline:
有一些理由允许你忽视这份指南：
1. When applying the guideline would make the code less readable, even
   for someone who is used to reading code that follows this PEP.
1.当应用这份指南导致代码的可读性变差时。
2. To be consistent with surrounding code that also breaks it (maybe
   for historic reasons) -- although this is also an opportunity to
   clean up someone else's mess (in true XP style).
2.为了与周围的代码风格保持一致。
3. Because the code in question predates the introduction of the
   guideline and there is no other reason to be modifying that code.
3.代码早于本指南，且没有其他修改理由。
4. When the code needs to remain compatible with older versions of
   Python that don't support the feature recommended by the style guide.
4.当代码需要与不支持本指南的旧版本Python兼容时。

Code Lay-out 代码布局
============

Indentation 缩进
-----------

Use 4 spaces per indentation level.
每一级缩进使用4个空格。
Continuation lines should align wrapped elements either vertically
using Python's implicit line joining inside parentheses, brackets and
braces, or using a *hanging indent* [#fn-hi]_.  
When using a hanging indent the following should be considered; 
there should be no arguments on the first line and further indentation 
should be used to clearly distinguish itself as a continuation line.
续行应该垂直对齐包裹在括号内的元素或使用悬挂缩进。
当使用悬挂缩进时应考虑以下内容：
第一行不应有任何参数，并且应该使用进一步的缩进来清楚的将其区分为连续行。
Yes::正例

    # Aligned with opening delimiter.# 与左括号对齐
    foo = long_function_name(var_one, var_two,
                             var_three, var_four)

    # Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest.
    # 用更多的缩进来与其他行区分
	def long_function_name(
            var_one, var_two, var_three,
            var_four):
        print(var_one)

    # Hanging indents should add a level.# 悬挂缩进应该加一个缩进
    foo = long_function_name(
        var_one, var_two,
        var_three, var_four)

No::反例

    # Arguments on first line forbidden when not using vertical alignment.
	# 没有使用垂直对齐时，禁止把参数放在第一行
    foo = long_function_name(var_one, var_two,
        var_three, var_four)

    # Further indentation required as indentation is not distinguishable.
	# 当缩进没有与其他行区分时，要增加缩进
    def long_function_name(
        var_one, var_two, var_three,
        var_four):
        print(var_one)

The 4-space rule is optional for continuation lines.

Optional::可选

    # Hanging indents *may* be indented to other than 4 spaces.
	# 悬挂缩进不一定要用4个空格
    foo = long_function_name(
      var_one, var_two,
      var_three, var_four)

.. _`multiline if-statements`:多行if语句

When the conditional part of an ``if``-statement is long enough to require
that it be written across multiple lines, it's worth noting that the
combination of a two character keyword (i.e. ``if``), plus a single space,
plus an opening parenthesis creates a natural 4-space indent for the
subsequent lines of the multiline conditional.
当if语句的条件部分过长需要分行时，if加上1个空格加上1个（会为
后续行添加一个自然的缩进。
This can produce a visual conflict with the indented suite of code 
nested inside the ``if``-statement, which would also naturally be 
indented to 4 spaces.  
这可能会与嵌套在“if”语句中的缩进代码集产生视觉冲突。
This PEP takes no explicit position on how (or whether) to further 
visually distinguish such conditional lines from the nested suite 
inside the ``if``-statement.
对于如何进一步从视觉上区分这些条件行与“if”语句中嵌套的代码，
PEP没有明确的立场。
Acceptable options in this situation include, but are not limited to::
可接受但不限于以下情况。
    # No extra indentation.# 没有额外的缩进
    if (this_is_one_thing and
        that_is_another_thing):
        do_something()

    # Add a comment, which will provide some distinction in editors
    # supporting syntax highlighting.
	# 增加一个注释，在能提供语法高亮的编辑器中可以有一些区分
    if (this_is_one_thing and
        that_is_another_thing):
        # Since both conditions are true, we can frobnicate.
        do_something()

    # Add some extra indentation on the conditional continuation line.
	# 在条件判断的语句添加额外的缩进
    if (this_is_one_thing
            and that_is_another_thing):
        do_something()

(Also see the discussion of whether to break before or after binary
operators below.)
（可以参考下面关于是否在二进制运算符之前或之后截断的讨论） 
The closing brace/bracket/parenthesis on multiline constructs may
either line up under the first non-whitespace character of the last
line of list, as in::
在多行结构中的大括号/中括号/小括号的右括号可以与内容对齐单独起一行
作为最后一行的第一个字符，就像这样：
    my_list = [
        1, 2, 3,
        4, 5, 6,
        ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f',
        )

or it may be lined up under the first character of the line that
starts the multiline construct, as in::
或者也可以与多行结构的第一行第一个字符对齐，就像这样
    my_list = [
        1, 2, 3,
        4, 5, 6,
    ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f',
    )

Tabs or Spaces? 制表符VS空格
---------------

Spaces are the preferred indentation method.
空格是首选的缩进方式。
Tabs should be used solely to remain consistent with code that is
already indented with tabs.
制表符只能用于与同样使用制表符缩进的代码保持一致。
Python 3 disallows mixing the use of tabs and spaces for indentation.
Python3不允许同时使用空格和制表符的缩进。
Python 2 code indented with a mixture of tabs and spaces should be
converted to using spaces exclusively.
混合使用制表符和空格缩进的Python2代码应该统一转成空格。
When invoking the Python 2 command line interpreter with the ``-t`` option,
it issues warnings about code that illegally mixes tabs and spaces.  
当在命令行加入-t选项执行Python2时，它会发出关于非法混用制表符与空格的警告。
When using ``-tt`` these warnings become errors.
当使用–tt时，这些警告会变成错误。
These options are highly recommended!
强烈建议使用这样的参数。

Maximum Line Length 行的最大长度
-------------------

Limit all lines to a maximum of 79 characters.
所有行限制的最大字符数为79。
For flowing long blocks of text with fewer structural restrictions
(docstrings or comments), the line length should be limited to 72
characters.
没有结构化限制的大块文本（文档字符或者注释），每行的最大字符数限制在72。
Limiting the required editor window width makes it possible to have
several files open side-by-side, and works well when using code
review tools that present the two versions in adjacent columns.
限制编辑器窗口宽度可以使多个文件并行打开，
并且在使用代码检查工具(在相邻列中显示这两个版本)时工作得很好。
The default wrapping in most tools disrupts the visual structure of the
code, making it more difficult to understand. 
大多数工具中的默认封装破坏了代码的可视化结构，使代码更难以理解。
The limits are chosen to avoid wrapping in editors with the window width 
set to 80, even if the tool places a marker glyph in the final column 
when wrapping lines. 
避免使用编辑器中默认配置的80窗口宽度，即使工具在帮你折行时在最后一列
放了一个标记符。
Some web based tools may not offer dynamic line wrapping at all.
某些基于Web的工具可能根本不提供动态折行。
Some teams strongly prefer a longer line length.  
一些团队更喜欢较长的行宽。
For code maintained exclusively or primarily by a team that can 
reach agreement on this issue, it is okay to increase 
the line length limit up to 99 characters, provided that comments 
and docstrings are still wrapped at 72 characters.
如果代码主要由一个团队维护，那这个问题就能达成一致，
可以把行长度从80增加到100个字符（更有效的做法是将行最大长度增加到99个字符）
，前提是注释和文档字符串依然已72字符折行。 
The Python standard library is conservative and requires limiting
lines to 79 characters (and docstrings/comments to 72).
Python标准库比较保守，需要将行宽限制在79个字符（文档/注释限制在72）。
The preferred way of wrapping long lines is by using Python's implied
line continuation inside parentheses, brackets and braces.  
较长的代码行选择Python在小括号，中括号以及大括号中的隐式续行方式。
Long lines can be broken over multiple lines by wrapping expressions 
in parentheses. 
通过小括号内表达式的换行方式将长串折成多行。 
These should be used in preference to using a backslash for 
line continuation.
这种方式应该优先使用，而不是使用反斜杠续行。
Backslashes may still be appropriate at times.  
反斜杠有时依然很有用。
For example, long, multiple ``with``-statements cannot use 
implicit continuation, so backslashes are acceptable::
比如，比较长的，多个with状态语句，不能使用隐式续行，
所以反斜杠是可以接受的：
    with open('/path/to/some/file/you/want/to/read') as file_1, \
         open('/path/to/some/file/being/written', 'w') as file_2:
        file_2.write(file_1.read())

(See the previous discussion on `multiline if-statements`_ for further
thoughts on the indentation of such multiline ``with``-statements.)
（请参阅前面关于多行if-语句的讨论，以获得关于这种多行with-语句缩进
的进一步想法。） 
Another such case is with ``assert`` statements.
另一种类似情况是使用assert语句。 
Make sure to indent the continued line appropriately.
确保在续行进行适当的缩进。

Should a Line Break Before or After a Binary Operator?
在二元运算符之前应该换行吗？
------------------------------------------------------

For decades the recommended style was to break after binary operators.
几十年来，推荐的风格是在二元运算符之后中断。
But this can hurt readability in two ways: 
但是这回影响可读性，原因有二：
the operators tend to get scattered across different columns 
on the screen, and each operator is moved away from 
its operand and onto the previous line.  
操作符一般分布在屏幕上不同的列中，而且每个运算符被移到了操作数的上一行。
Here, the eye has to do extra work to tell which items are added and 
which are subtracted::
下面例子这个情况就需要额外注意，那些变量是相加的，那些变量是相减的：
    # No: operators sit far away from their operands
	# 不推荐: 操作符离操作数太远
    income = (gross_wages +
              taxable_interest +
              (dividends - qualified_dividends) -
              ira_deduction -
              student_loan_interest)

To solve this readability problem, mathematicians and their publishers
follow the opposite convention.  
为了解决这种可读性的问题，数学家和他们的出版商遵循了相反的约定。
Donald Knuth explains the traditional rule in his *Computers and 
Typesetting* series: 
Donald Knuth在他的Computers and Typesetting系列中解释了传统规则：
"Although formulas within a paragraph always break after binary operations 
and relations, displayed formulas always break before binary operations" [3]_.
“尽管段落中的公式总是在二元运算符和关系之后中断，
显示出来的公式总是要在二元运算符之前中断”
Following the tradition from mathematics usually results in more
readable code::
遵循数学的传统能产出更多可读性高的代码：
    # Yes: easy to match operators with operands
	# 推荐：运算符和操作数很容易进行匹配
    income = (gross_wages
              + taxable_interest
              + (dividends - qualified_dividends)
              - ira_deduction
              - student_loan_interest)

In Python code, it is permissible to break before or after a binary
operator, as long as the convention is consistent locally.  
在Python代码中，允许在二元运算符之前或之后中断，只要本地的约定是一致的。
For new code Knuth's style is suggested.
对于新代码，建议使用Knuth的样式。

Blank Lines 空行
-----------

Surround top-level function and class definitions with two blank
lines.
顶层函数和类的定义，前后用两个空行隔开。
Method definitions inside a class are surrounded by a single blank
line.
类里的方法定义用一个空行隔开。 
Extra blank lines may be used (sparingly) to separate groups of
related functions.  
相关的功能组可以用额外的空行（谨慎使用）隔开。
Blank lines may be omitted between a bunch of related one-liners 
(e.g. a set of dummy implementations).
一堆相关的单行代码之间的空白行可以省略
（例如，一组虚拟实现 dummy implementations）。 
Use blank lines in functions, sparingly, to indicate logical sections.
在函数中使用空行来区分逻辑段（谨慎使用）。 
Python accepts the control-L (i.e. ^L) form feed character as
whitespace; 
Python接受control-L（即^L）换页符作为空格；
Many tools treat these characters as page separators, so you may use 
them to separate pages of related sections of your file.
许多工具把这些字符当作页面分隔符，所以你可以在文件中使用它们来分隔相关段落。
Note, some editors and web-based code viewers may not recognize
control-L as a form feed and will show another glyph in its place.
请注意，一些编辑器和基于Web的代码阅读器可能无法识别control-L为换页，
将在其位置显示另一个字形。

Source File Encoding 源文件编码
--------------------

Code in the core Python distribution should always use UTF-8 (or ASCII
in Python 2).
Python核心发布版本中的代码总是以UTF-8格式编码
（或者在Python2中用ASCII编码）。
Files using ASCII (in Python 2) or UTF-8 (in Python 3) should not have
an encoding declaration.
使用ASCII（在Python2中）或UTF-8（在Python3中）编码的文件不应具有编码声明。 
In the standard library, non-default encodings should be used only for
test purposes or when a comment or docstring needs to mention an author
name that contains non-ASCII characters; otherwise, using ``\x``,
``\u``, ``\U``, or ``\N`` escapes is the preferred way to include
non-ASCII data in string literals.
在标准库中，非默认的编码应该只用于测试，或者当一个注释或者文档字符串需要
提及一个包含内ASCII字符编码的作者名字的时候；
否则，使用\x,\u,\U , 或者 \N 进行转义来包含非ASCII字符。
For Python 3.0 and beyond, the following policy is prescribed for the
standard library (see PEP 3131): 
对于Python 3和更高版本，标准库规定了以下策略（参见 PEP 3131）：
All identifiers in the Python standard library MUST use ASCII-only 
identifiers, and SHOULD use English words wherever feasible 
(in many cases, abbreviations and technical terms are used which aren't 
English). 
Python标准库中的所有标识符必须使用ASCII标识符，并在可行的情况下
使用英语单词（在许多情况下，缩写和技术术语是非英语的）。
In addition, string literals and comments must also be in ASCII. 
此外，字符串文字和注释也必须是ASCII。
The only exceptions are 唯一的例外是
(a) test cases testing the non-ASCII features, and
（a）测试非ASCII特征的测试用例
(b) names of authors. 
（b）作者的名称。
Authors whose names are not based on the Latin alphabet 
(latin-1, ISO/IEC 8859-1 character set) MUST provide
a transliteration of their names in this character set.
作者的名字如果不使用拉丁字母拼写，必须提供一个拉丁字母的音译。 
Open source projects with a global audience are encouraged to adopt a
similar policy.
鼓励具有全球受众的开放源码项目采取类似的政策。

Imports 导入
-------

- Imports should usually be on separate lines::导入通常在分开的行，例如

      Yes: import os
           import sys

      No:  import sys, os

  It's okay to say this though::但是可以这样：

      from subprocess import Popen, PIPE

- Imports are always put at the top of the file, just after any module
  comments and docstrings, and before module globals and constants.
  导入总是位于文件的顶部，在模块注释和文档字符串之后，
  在模块的全局变量与常量之前。 
  Imports should be grouped in the following order:
  导入应该按照以下顺序分组：
  1. Standard library imports. 标准库导入
  2. Related third party imports. 相关第三方库导入
  3. Local application/library specific imports. 本地应用/库特定导入

  You should put a blank line between each group of imports.
  你应该在每一组导入之间加入空行。
- Absolute imports are recommended, as they are usually more readable
  and tend to be better behaved (or at least give better error
  messages) if the import system is incorrectly configured (such as
  when a directory inside a package ends up on ``sys.path``)::

      import mypkg.sibling
      from mypkg import sibling
      from mypkg.sibling import example
  推荐使用绝对路径导入，如果导入系统没有正确的配置（比如包里的一个目录在
  sys.path里的路径后），使用绝对路径会更加可读并且性能更好（至少能
  提供更好的错误信息）:
  However, explicit relative imports are an acceptable alternative to
  absolute imports, especially when dealing with complex package layouts
  where using absolute imports would be unnecessarily verbose::
  然而，显示的指定相对导入路径是使用绝对路径的一个可接受的替代方案，
  特别是在处理使用绝对路径导入不必要冗长的复杂包布局时：
      from . import sibling
      from .sibling import example

  Standard library code should avoid complex package layouts and always
  use absolute imports.
  标准库要避免使用复杂的包引入结构，而总是使用绝对路径。
  Implicit relative imports should *never* be used and have been removed
  in Python 3.
  不应该使用隐式相对路径导入，并且在Python 3中删除了它。
- When importing a class from a class-containing module, it's usually
  okay to spell this::
  当从一个包含类的模块中导入类时，常常这么写：
      from myclass import MyClass
      from foo.bar.yourclass import YourClass

  If this spelling causes local name clashes, then spell them explicitly::
  如果上述的写法导致名字的冲突，那么这么写：
      import myclass
      import foo.bar.yourclass

  and use "myclass.MyClass" and "foo.bar.yourclass.YourClass".
  然后使用“myclass.MyClass”和“foo.bar.yourclass.YourClass”。
- Wildcard imports (``from <module> import *``) should be avoided, as
  they make it unclear which names are present in the namespace,
  confusing both readers and many automated tools. There is one
  defensible use case for a wildcard import, which is to republish an
  internal interface as part of a public API (for example, overwriting
  a pure Python implementation of an interface with the definitions
  from an optional accelerator module and exactly which definitions
  will be overwritten isn't known in advance).
  避免通配符的导入（from import *），因为这样做会不知道命名空间中存在
  哪些名字，会使得读取接口和许多自动化工具之间产生混淆。
  对于通配符的导入，有一个防御性的做法，即将内部接口重新发布为
  公共API的一部分（例如，用可选加速器模块的定义覆盖纯Python实现的
  接口，以及重写那些事先不知道的定义）。 
  When republishing names this way, the guidelines below regarding
  public and internal interfaces still apply.
  当以这种方式重新发布名称时，以下关于公共和内部接口的准则仍然适用。

Module Level Dunder Names 模块级的“呆”名
-------------------------

Module level "dunders" (i.e. names with two leading and two trailing
underscores) such as ``__all__``, ``__author__``, ``__version__``,
etc. should be placed after the module docstring but before any import
statements *except* ``from __future__`` imports.  
像__all__ , __author__ , __version__ 等这样的模块级“呆名“（也就是名字里
有两个前缀下划线和两个后缀下划线），应该放在文档字符串的后面，
以及除from __future__ 之外的import表达式前面。
Python mandates that future-imports must appear in the module before 
any other code except docstrings::
Python要求将来在模块中的导入，必须出现在除文档字符串之外的其他代码之前。 
    """This is the example module.

    This module does stuff.
    """

    from __future__ import barry_as_FLUFL

    __all__ = ['a', 'b', 'c']
    __version__ = '0.1'
    __author__ = 'Cardinal Biggles'

    import os
    import sys


String Quotes 字符串引号
=============

In Python, single-quoted strings and double-quoted strings are the
same.  
在Python中，单引号和双引号字符串是相同的。
This PEP does not make a recommendation for this.  
PEP不会为这个给出建议。
Pick a rule and stick to it.  
选择一条规则并坚持使用下去。
When a string contains single or double quotecharacters, 
however, use the other one to avoid backslashes in the string. 
It improves readability.
当一个字符串中包含单引号或者双引号字符的时候，
使用和最外层不同的符号来避免使用反斜杠，从而提高可读性。
For triple-quoted strings, always use double quote characters to be
consistent with the docstring convention in PEP 257.
对于三引号字符串，总是使用双引号字符
来与PEP 257中的文档字符串约定保持一致。

Whitespace in Expressions and Statements
表达式和语句中的空格
========================================

Pet Peeves 不能忍受的事情
----------

Avoid extraneous whitespace in the following situations:
在下列情况下，避免使用无关的空格：
- Immediately inside parentheses, brackets or braces. ::
  紧跟在小括号，中括号或者大括号后。
      Yes: spam(ham[1], {eggs: 2})
      No:  spam( ham[ 1 ], { eggs: 2 } )

- Between a trailing comma and a following close parenthesis. ::
  在结尾逗号和后面的右括号之间。
      Yes: foo = (0,)
      No:  bar = (0, )

- Immediately before a comma, semicolon, or colon::
  紧贴在逗号、分号或者冒号之前。
      Yes: if x == 4: print x, y; x, y = y, x
      No:  if x == 4 : print x , y ; x , y = y , x

- However, in a slice the colon acts like a binary operator, and
  should have equal amounts on either side (treating it as the
  operator with the lowest priority).  
  然而，冒号在切片中就像二元运算符，在两边应该有相同数量的空格
  （把它当做优先级最低的操作符）。
  In an extended slice, both colons must have the same amount of 
  spacing applied.  
  在扩展的切片操作中，所有的冒号必须有相同的间距。
  Exception: 例外情况：
  when a slice parameter is omitted, the space is omitted.
  当一个切片参数被省略时，空格就被省略了。 
  Yes::

      ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
      ham[lower:upper], ham[lower:upper:], ham[lower::step]
      ham[lower+offset : upper+offset]
      ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
      ham[lower + offset : upper + offset]

  No::

      ham[lower + offset:upper + offset]
      ham[1: 9], ham[1 :9], ham[1:9 :3]
      ham[lower : : upper]
      ham[ : upper]

- Immediately before the open parenthesis that starts the argument
  list of a function call::
  紧贴在函数参数的左括号之前。
      Yes: spam(1)
      No:  spam (1)

- Immediately before the open parenthesis that starts an indexing or
  slicing::
  紧贴索引或者切片的左括号之前。
      Yes: dct['key'] = lst[index]
      No:  dct ['key'] = lst [index]

- More than one space around an assignment (or other) operator to
  align it with another.
  为了和另一个赋值语句对齐，在赋值运算符附件加多个空格。 
  Yes::

      x = 1
      y = 2
      long_variable = 3

  No::

      x             = 1
      y             = 2
      long_variable = 3

Other Recommendations 其他建议
---------------------

- Avoid trailing whitespace anywhere.  Because it's usually invisible,
  it can be confusing: e.g. a backslash followed by a space and a
  newline does not count as a line continuation marker.  Some editors
  don't preserve it and many projects (like CPython itself) have
  pre-commit hooks that reject it.
  避免在尾部添加空格。因为尾部的空格通常都看不见，会产生混乱：
  比如，一个反斜杠后面跟一个空格的换行符，不算续行标记。
  有些编辑器不会保留尾空格，并且很多项目（像CPython）
  在pre-commit的挂钩调用中会过滤掉尾空格。
- Always surround these binary operators with a single space on either
  side: assignment (``=``), augmented assignment (``+=``, ``-=``
  etc.), comparisons (``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``,
  ``>=``, ``in``, ``not in``, ``is``, ``is not``), Booleans (``and``,
  ``or``, ``not``).
  总是在二元运算符两边加一个空格：赋值（=），增量赋值（+=，-=），
  比较（==,<,>,!=,<>,<=,>=,in,not,in,is,is not），布尔（and, or, not）。
- If operators with different priorities are used, consider adding
  whitespace around the operators with the lowest priority(ies). Use
  your own judgment; however, never use more than one space, and
  always have the same amount of whitespace on both sides of a binary
  operator.
  如果使用具有不同优先级的运算符，请考虑在具有最低优先级的运算符周围
  添加空格。有时需要通过自己来判断；
  但是，不要使用一个以上的空格，并且在二元运算符的两边使用相同数量的空格。
  Yes::

      i = i + 1
      submitted += 1
      x = x*2 - 1
      hypot2 = x*x + y*y
      c = (a+b) * (a-b)

  No::

      i=i+1
      submitted +=1
      x = x * 2 - 1
      hypot2 = x * x + y * y
      c = (a + b) * (a - b)

- Function annotations should use the normal rules for colons and
  always have spaces around the ``->`` arrow if present.  (See
  `Function Annotations`_ below for more about function annotations.)
  功能型注释应该使用冒号的一般性规则，并且在使用->的时候要在两边加空格。
  （参考下面的功能注释得到能够多信息）
  Yes::

      def munge(input: AnyStr): ...
      def munge() -> AnyStr: ...

  No::

      def munge(input:AnyStr): ...
      def munge()->PosInt: ...

- Don't use spaces around the ``=`` sign when used to indicate a
  keyword argument, or when used to indicate a default value for an
  *unannotated* function parameter.
  在制定关键字参数或者默认参数值的时候，不要在=附近加上空格。
  Yes::

      def complex(real, imag=0.0):
          return magic(r=real, i=imag)

  No::

      def complex(real, imag = 0.0):
          return magic(r = real, i = imag)


  When combining an argument annotation with a default value, however, do use
  spaces around the ``=`` sign:
  当给有类型备注的参数赋值的时候，在=两边添加空格
  （仅针对那种有类型备注和默认值的参数）。 
  Yes::

      def munge(sep: AnyStr = None): ...
      def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...

  No::

      def munge(input: AnyStr=None): ...
      def munge(input: AnyStr, limit = 1000): ...

- Compound statements (multiple statements on the same line) are
  generally discouraged.
  复合语句(同一行中的多个语句)通常是不允许的。 
  Yes::

      if foo == 'blah':
          do_blah_thing()
      do_one()
      do_two()
      do_three()

  Rather not::

      if foo == 'blah': do_blah_thing()
      do_one(); do_two(); do_three()

- While sometimes it's okay to put an if/for/while with a small body
  on the same line, never do this for multi-clause statements.  Also
  avoid folding such long lines!
  虽然有时候将小的代码块和 if/for/while 放在同一行没什么问题，
  多行语句块的情况不要这样用，同样也要避免代码行太长！ 
  Rather not::最好别这样

      if foo == 'blah': do_blah_thing()
      for x in lst: total += x
      while t < 10: t = delay()

  Definitely not::绝对别这样

      if foo == 'blah': do_blah_thing()
      else: do_non_blah_thing()

      try: something()
      finally: cleanup()

      do_one(); do_two(); do_three(long, argument,
                                   list, like, this)

      if foo == 'blah': one(); two(); three()


When to Use Trailing Commas 使用结尾逗号的时候
===========================

Trailing commas are usually optional, except they are mandatory when
making a tuple of one element (and in Python 2 they have semantics for
the ``print`` statement).  For clarity, it is recommended to surround
the latter in (technically redundant) parentheses.
结尾逗号经常是可选的，除非它们在构成一个元素的元组时是必需的
（在python2中，它们具有``print``语句的语义）。
为了清楚起见，建议将后者括在（技术上冗余的）括号中。
Yes::

    FILES = ('setup.cfg',)

OK, but confusing::

    FILES = 'setup.cfg',

When trailing commas are redundant, they are often helpful when a
version control system is used, when a list of values, arguments or
imported items is expected to be extended over time.  The pattern is
to put each value (etc.) on a line by itself, always adding a trailing
comma, and add the close parenthesis/bracket/brace on the next line.
However it does not make sense to have a trailing comma on the same
line as the closing delimiter (except in the above case of singleton
tuples).


当尾随逗号是多余的时，当使用版本控制系统时，当期望值、参数或导入项的列表
随着时间的推移而扩展时，尾随逗号通常很有用。 
模式是将每个值（等）单独放在一行上，始终添加一个尾随逗号，并在下一行
添加右括号/括号/大括号。
但是，在结束分隔符的同一行使用尾随逗号是没有意义的（上面的单例元组除外）。
Yes::

    FILES = [
        'setup.cfg',
        'tox.ini',
        ]
    initialize(FILES,
               error=True,
               )

No::

    FILES = ['setup.cfg', 'tox.ini',]
    initialize(FILES, error=True,)


Comments 注释
========

Comments that contradict the code are worse than no comments.  Always
make a priority of keeping the comments up-to-date when the code
changes!
与代码相矛盾的注释比没有注释还糟，当代码更改时，优先更新对应的注释！
Comments should be complete sentences.  The first word should be
capitalized, unless it is an identifier that begins with a lower case
letter (never alter the case of identifiers!).
注释应该是完整的句子。如果一个注释是一个短语或句子，
它的第一个单词应该大写，除非它是以小写字母开头的标识符
(永远不要改变标识符的大小写！)。 
Block comments generally consist of one or more paragraphs built out of
complete sentences, with each sentence ending in a period.
如果注释很短，结尾的句号可以省略。
块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号。
You should use two spaces after a sentence-ending period in multi-
sentence comments, except after the final sentence.
在句尾结束的时候应该使用两个空格。
When writing English, follow Strunk and White.
当用英文书写时，遵循Strunk and White 
（译注：《Strunk and White, The Elements of Style》）的书写风格。 
Python coders from non-English speaking countries: please write your
comments in English, unless you are 120% sure that the code will never
be read by people who don't speak your language.
在非英语国家的Python程序员，请使用英文写注释，
除非你120%的确信你的代码不会被使用其他语言的人阅读。

Block Comments 块注释
--------------

Block comments generally apply to some (or all) code that follows
them, and are indented to the same level as that code.  Each line of a
block comment starts with a ``#`` and a single space (unless it is
indented text inside the comment).
块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。
块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 
Paragraphs inside a block comment are separated by a line containing a
single ``#``.
块注释内部的段落通过只有一个#的空行分隔。

Inline Comments 行注释
---------------

Use inline comments sparingly.
有节制地使用行内注释。
An inline comment is a comment on the same line as a statement.
Inline comments should be separated by at least two spaces from the
statement.  They should start with a # and a single space.
行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。
注释由#和一个空格开始。
Inline comments are unnecessary and in fact distracting if they state
the obvious.  Don't do this::
事实上，如果状态明显的话，行内注释是不必要的，反而会分散注意力。
比如说下面这样就不需要：
    x = x + 1                 # Increment x

But sometimes, this is useful:: 但有时，这样做很有用：

    x = x + 1                 # Compensate for border

Documentation Strings 文档字符
---------------------

Conventions for writing good documentation strings
(a.k.a. "docstrings") are immortalized in PEP 257.
编写好的文档说明（也叫“docstrings”）的约定在PEP 257中永恒不变。
- Write docstrings for all public modules, functions, classes, and
  methods.  Docstrings are not necessary for non-public methods, but
  you should have a comment that describes what the method does.  This
  comment should appear after the ``def`` line.
  要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，
  但是应该有一个描述方法具体作用的注释。
  这个注释应该在def那一行之后。
- PEP 257 describes good docstring conventions.  Note that most
  importantly, the ``"""`` that ends a multiline docstring should be
  on a line by itself::
  PEP 257 描述了写出好的文档说明相关的约定。特别需要注意的是，
  多行文档说明使用的结尾三引号应该自成一行，例如：
      """Return a foobang

      Optional plotz says to frobnicate the bizbaz first.
      """

- For one liner docstrings, please keep the closing ``"""`` on
  the same line.
  对于单行的文档说明，尾部的三引号应该和文档在同一行。

Naming Conventions 命名规范
==================

The naming conventions of Python's library are a bit of a mess, so
we'll never get this completely consistent -- nevertheless, here are
the currently recommended naming standards.  New modules and packages
(including third party frameworks) should be written to these
standards, but where an existing library has a different style,
internal consistency is preferred.
Python库的命名规范很乱，从来没能做到完全一致。
但是目前有一些推荐的命名标准。
新的模块和包（包括第三方框架）应该用这套标准，
但当一个已有库采用了不同的风格，推荐保持内部一致性。

Overriding Principle 最重要的原则
--------------------

Names that are visible to the user as public parts of the API should
follow conventions that reflect usage rather than implementation.
那些暴露给用户的API接口的命名，应该遵循反映使用场景而不是实现的原则。

Descriptive: Naming Styles 描述：命名风格
--------------------------

There are a lot of different naming styles.  It helps to be able to
recognize what naming style is being used, independently from what
they are used for.
有许多不同的命名风格。这里能够帮助大家识别正在使用什么样的命名风格，
而不考虑他们为什么使用。
The following naming styles are commonly distinguished:
以下是常见的命名方式：

- ``b`` (single lowercase letter)（单个小写字母）
- ``B`` (single uppercase letter)（单个大写字母）
- ``lowercase``小写字母
- ``lower_case_with_underscores``使用下划线分隔的小写字母
- ``UPPERCASE``大写字母
- ``UPPER_CASE_WITH_UNDERSCORES``使用下划线分隔的大写字母
- ``CapitalizedWords`` (or CapWords, or CamelCase -- so named because
  of the bumpy look of its letters [4]_).  This is also sometimes known
  as StudlyCaps.
  （或者叫 CapWords，或者叫CamelCase 驼峰命名法 —— 
  这么命名是因为字母看上去有起伏的外观）。有时候也被称为StudlyCaps。
  Note: When using acronyms in CapWords, capitalize all the
  letters of the acronym.  Thus HTTPServerError is better than
  HttpServerError.
  注意：当在首字母大写的风格中用到缩写时，所有缩写的字母用大写，
  因此，HTTPServerError 比 HttpServerError 好。
- ``mixedCase`` (differs from CapitalizedWords by initial lowercase
  character!)
  （不同于首字母大写，第一个单词的首字母小写）
- ``Capitalized_Words_With_Underscores`` (ugly!)
  （巨丑无比！）
  
There's also the style of using a short unique prefix to group related
names together.  This is not used much in Python, but it is mentioned
for completeness.  For example, the ``os.stat()`` function returns a
tuple whose items traditionally have names like ``st_mode``,
``st_size``, ``st_mtime`` and so on.  (This is done to emphasize the
correspondence with the fields of the POSIX system call struct, which
helps programmers familiar with that.)
也有用唯一的短前缀把相关命名组织在一起的方法。
这在Python中不常用，但还是提一下。
比如，os.stat()函数中包含类似以st_mode，st_size，st_mtime
这种传统命名方式命名的变量。
（这么做是为了与 POSIX 系统的调用一致，以帮助程序员熟悉它。） 
The X11 library uses a leading X for all its public functions.  In
Python, this style is generally deemed unnecessary because attribute
and method names are prefixed with an object, and function names are
prefixed with a module name.
X11库的所有公共函数都加了前缀X。
在Python里面没必要这么做，因为属性和方法在调用的时候都会用类名做前缀，
函数名用模块名做前缀。 
In addition, the following special forms using leading or trailing
underscores are recognized (these can generally be combined with any
case convention):
另外，下面这种用前缀或结尾下划线的特殊格式是被认可的
（通常和一些约定相结合）：
- ``_single_leading_underscore``: weak "internal use" indicator.
  E.g. ``from M import *`` does not import objects whose names start
  with an underscore.
  （单下划线开头）弱“内部使用”指示器。
  比如 from M import * 是不会导入以下划线开始的对象的。
- ``single_trailing_underscore_``: used by convention to avoid
  conflicts with Python keyword, e.g. ::
  （单下划线结尾）这是避免和Python内部关键词冲突的一种约定，比如：
      Tkinter.Toplevel(master, class_='ClassName')

- ``__double_leading_underscore``: when naming a class attribute,
  invokes name mangling (inside class FooBar, ``__boo`` becomes
  ``_FooBar__boo``; see below).
  （双下划线开头）当这样命名一个类的属性时，调用它的时候名字会做矫正
  （在类FooBar中，__boo变成了_FooBar__boo；见下文）。
- ``__double_leading_and_trailing_underscore__``: "magic" objects or
  attributes that live in user-controlled namespaces.
  E.g. ``__init__``, ``__import__`` or ``__file__``.  Never invent
  such names; only use them as documented.
  双下划线开头，双下划线结尾）“magic”对象或者存在于用户控制的命名空间内
  的属性，例如：__init__,__import__或者__file__。
  除了作为文档之外，永远不要命这样的名。
  
Prescriptive: Naming Conventions 约定俗成：命名约定
--------------------------------

Names to Avoid 应避免的名字
~~~~~~~~~~~~~~

Never use the characters 'l' (lowercase letter el), 'O' (uppercase
letter oh), or 'I' (uppercase letter eye) as single character variable
names.
永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）
作为单字符变量名。
In some fonts, these characters are indistinguishable from the
numerals one and zero.  When tempted to use 'l', use 'L' instead.
在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。

ASCII Compatibility ASCII兼容性
~~~~~~~~~~~~~~~~~~~

Identifiers used in the standard library must be ASCII compatible
as described in the
`policy section <https://www.python.org/dev/peps/pep-3131/#policy-specification>`_
of PEP 3131.
标准库中使用的标识符必须与ASCII兼容

Package and Module Names 包名和模块名
~~~~~~~~~~~~~~~~~~~~~~~~

Modules should have short, all-lowercase names.  
模块应该用简短全小写的名字。
Underscores can be used in the module name if it improves readability.
如果为了提升可读性，下划线也是可以用的。 
Python packages should also have short, all-lowercase names, although 
the use of underscores is discouraged.
Python包名也应该使用简短全小写的名字，但不建议用下划线。 
When an extension module written in C or C++ has an accompanying
Python module that provides a higher level (e.g. more object oriented)
interface, the C/C++ module has a leading underscore (e.g. ``_socket``).
当使用C或者C++编写了一个依赖于提供高级（更面向对象）接口的Python模块
的扩展模块，这个C/C++模块需要一个下划线前缀（例如：_socket）

Class Names 类名
~~~~~~~~~~~

Class names should normally use the CapWords convention.
类名一般使用首字母大写的约定。 
The naming convention for functions may be used instead in cases where
the interface is documented and used primarily as a callable.
在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替。
Note that there is a separate convention for builtin names: most builtin
names are single words (or two words run together), with the CapWords
convention used only for exception names and builtin constants.
注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词
（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量。

Type Variable Names 类型变量名
~~~~~~~~~~~~~~~~~~~

Names of type variables introduced in PEP 484 should normally use CapWords
preferring short names: ``T``, ``AnyStr``, ``Num``. It is recommended to add
suffixes ``_co`` or ``_contra`` to the variables used to declare covariant
or contravariant behavior correspondingly::
PEP 484中引入的类型变量的名称通常应使用大写字母优先于短名称：
``t``、``anystr```、``num``。
建议在用于相应地声明协变或逆变行为的变量中
添加后缀``u co``或``u contra`：

    from typing import TypeVar

    VT_co = TypeVar('VT_co', covariant=True)
    KT_contra = TypeVar('KT_contra', contravariant=True)

Exception Names 异常名
~~~~~~~~~~~~~~~

Because exceptions should be classes, the class naming convention
applies here.  However, you should use the suffix "Error" on your
exception names (if the exception actually is an error).
因为异常一般都是类，所有类的命名方法在这里也适用。
然而，你需要在异常名后面加上“Error”后缀（如果异常确实是一个错误）。

Global Variable Names 全局变量名
~~~~~~~~~~~~~~~~~~~~~

(Let's hope that these variables are meant for use inside one module
only.)  The conventions are about the same as those for functions.
（我们希望这一类变量只在模块内部使用。）约定和函数命名规则一样。
Modules that are designed for use via ``from M import *`` should use
the ``__all__`` mechanism to prevent exporting globals, or use the
older convention of prefixing such globals with an underscore (which
you might want to do to indicate these globals are "module
non-public").
通过 from M import * 导入的模块应该使用all机制去防止内部的接口对外暴露，
或者使用在全局变量前加下划线的方式（表明这些全局变量是模块内非公有）。

Function and Variable Names 函数名和变量名
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Function names should be lowercase, with words separated by
underscores as necessary to improve readability.
函数名应该小写，如果想提高可读性可以用下划线分隔。 
Variable names follow the same convention as function names.
变量名遵循与函数名相同的约定。
mixedCase is allowed only in contexts where that's already the
prevailing style (e.g. threading.py), to retain backwards
compatibility.
大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用
（比如 threading.py），保持向后兼容性。

Function and Method Arguments 函数和方法参数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Always use ``self`` for the first argument to instance methods.
始终要将 self 作为实例方法的的第一个参数
Always use ``cls`` for the first argument to class methods.
始终要将 cls 作为类静态方法的第一个参数。
If a function argument's name clashes with a reserved keyword, it is
generally better to append a single trailing underscore rather than
use an abbreviation or spelling corruption.  Thus ``class_`` is better
than ``clss``.  (Perhaps better is to avoid such clashes by using a
synonym.)
如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。
因此 class_ 比 clss 更好。（也许最好用同义词来避免这种冲突）

Method Names and Instance Variables 方法名和实例变量
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the function naming rules: lowercase with words separated by
underscores as necessary to improve readability.
遵循这样的函数命名规则：使用下划线分隔小写单词以提高可读性。
Use one leading underscore only for non-public methods and instance
variables.
在非共有方法和实例变量前使用单下划线。 
To avoid name clashes with subclasses, use two leading underscores to
invoke Python's name mangling rules.
通过双下划线前缀触发Python的命名转换规则来避免和子类的命名冲突
Python mangles these names with the class name: if class Foo has an
attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An
insistent user could still gain access by calling ``Foo._Foo__a``.)
Generally, double leading underscores should be used only to avoid
name conflicts with attributes in classes designed to be subclassed.
Python通过类名对这些命名进行转换：如果类 Foo 有一个叫 __a 的成员变量，
它无法通过 Foo.__a 访问。（执着的用户可以通过 Foo._Foo__a 访问。）
一般来说，前缀双下划线用来避免类中的属性命名与子类冲突的情况。
Note: there is some controversy about the use of __names (see below).
注意：关于__names的用法存在争论（见下文）。

Constants 常量
~~~~~~~~~

Constants are usually defined on a module level and written in all
capital letters with underscores separating words.  Examples include
``MAX_OVERFLOW`` and ``TOTAL``.
常量通常定义在模块级，通过下划线分隔的全大写字母命名。
例如： MAX_OVERFLOW 和 TOTAL。

Designing for Inheritance 继承的设计
~~~~~~~~~~~~~~~~~~~~~~~~~

Always decide whether a class's methods and instance variables
(collectively: "attributes") should be public or non-public.  If in
doubt, choose non-public; it's easier to make it public later than to
make a public attribute non-public.
始终要考虑到一个类的方法和实例变量（统称：属性）应该是共有还是非共有。
如果存在疑问，那就选非共有；因为将一个非共有变量转为共有比反过来更容易。 
Public attributes are those that you expect unrelated clients of your
class to use, with your commitment to avoid backwards incompatible
changes.  Non-public attributes are those that are not intended to be
used by third parties; you make no guarantees that non-public
attributes won't change or even be removed.
公共属性是那些与类无关的客户使用的属性，并承诺避免向后不兼容的更改。
非共有属性是那些不打算让第三方使用的属性；
你不需要承诺非共有属性不会被修改或被删除。
We don't use the term "private" here, since no attribute is really
private in Python (without a generally unnecessary amount of work).
我们不使用“私有（private）”这个说法，是因为在Python中目前还没有
真正的私有属性（为了避免大量不必要的常规工作）。
Another category of attributes are those that are part of the
"subclass API" (often called "protected" in other languages).  Some
classes are designed to be inherited from, either to extend or modify
aspects of the class's behavior.  When designing such a class, take
care to make explicit decisions about which attributes are public,
which are part of the subclass API, and which are truly only to be
used by your base class.
另一种属性作为子类API的一部分（在其他语言中通常被称为“protected”）。
有些类是专为继承设计的，用来扩展或者修改类的一部分行为。
当设计这样的类时，要谨慎决定哪些属性时公开的，哪些是作为子类的API，
哪些只能在基类中使用。
With this in mind, here are the Pythonic guidelines:
贯彻这样的思想，一下是一些让代码Pythonic的准则：
- Public attributes should have no leading underscores.
  公共属性不应该有前缀下划线。
- If your public attribute name collides with a reserved keyword,
  append a single trailing underscore to your attribute name.  This is
  preferable to an abbreviation or corrupted spelling.  (However,
  notwithstanding this rule, 'cls' is the preferred spelling for any
  variable or argument which is known to be a class, especially the
  first argument to a class method.)
  如果公共属性名和关键字冲突，在属性名之后增加一个下划线。
  这比缩写和随意拼写好很多。
  （然而，尽管有这样的规则，在作为参数或者变量时，‘cls’是表示‘类’最好的选择，
  特别是作为类方法的第一个参数。）
  Note 1: See the argument name recommendation above for class methods.
  注意1：参考之前的类方法参数命名建议
- For simple public data attributes, it is best to expose just the
  attribute name, without complicated accessor/mutator methods.  Keep
  in mind that Python provides an easy path to future enhancement,
  should you find that a simple data attribute needs to grow
  functional behavior.  In that case, use properties to hide
  functional implementation behind simple data attribute access
  syntax.
  对于单一的共有属性数据，最好直接对外暴露它的变量名，
  而不是通过负责的存取器（accessor）/突变（mutator）方法。
  请记住，如果你发现一个简单的属性需要成长为一个功能行为，
  那么Python为这种将来会出现的扩展提供了一个简单的途径。
  在这种情况下，使用属性去隐藏属性数据访问背后的逻辑。
  Note 1: Properties only work on new-style classes.
  注意1：属性只在new-style类中起作用。
  Note 2: Try to keep the functional behavior side-effect free,
  although side-effects such as caching are generally fine.
  注意2：尽管功能方法对于类似缓存的负面影响比较小，但还是要尽量避免。
  Note 3: Avoid using properties for computationally expensive
  operations; the attribute notation makes the caller believe that
  access is (relatively) cheap.
  注意3：属性标记会让调用者认为开销（相当的）小，
  避免用属性做开销大的计算。
- If your class is intended to be subclassed, and you have attributes
  that you do not want subclasses to use, consider naming them with
  double leading underscores and no trailing underscores.  This
  invokes Python's name mangling algorithm, where the name of the
  class is mangled into the attribute name.  This helps avoid
  attribute name collisions should subclasses inadvertently contain
  attributes with the same name.
  如果你的类打算用来继承的话，并且这个类里有不希望子类使用的属性，
  就要考虑使用双下划线前缀并且没有后缀下划线的命名方式。
  这会调用Python的命名转换算法，将类的名字加入到属性名里。
  这样做可以帮助避免在子类中不小心包含了相同的属性名而产生的冲突。
  Note 1: Note that only the simple class name is used in the mangled
  name, so if a subclass chooses both the same class name and attribute
  name, you can still get name collisions.
  注意1：只有类名才会整合进属性名，如果子类的属性名和类名和父类都相同，
  那么你还是会有命名冲突的问题。
  Note 2: Name mangling can make certain uses, such as debugging and
  ``__getattr__()``, less convenient.  However the name mangling
  algorithm is well documented and easy to perform manually.
  注意2：命名转换会在某些场景使用起来不太方便，例如调试，__getattr__()。
  然而命名转换的算法有很好的文档说明并且很好操作。
  Note 3: Not everyone likes name mangling.  Try to balance the
  need to avoid accidental name clashes with potential use by
  advanced callers.
  注意3：不是所有人都喜欢命名转换。
  尽量避免意外的名字冲突和潜在的高级调用。
  
Public and Internal Interfaces 公共和内部的接口
------------------------------

Any backwards compatibility guarantees apply only to public interfaces.
Accordingly, it is important that users be able to clearly distinguish
between public and internal interfaces.
任何向后兼容保证只适用于公共接口，
因此，用户清晰地区分公共接口和内部接口非常重要。 
Documented interfaces are considered public, unless the documentation
explicitly declares them to be provisional or internal interfaces exempt
from the usual backwards compatibility guarantees. All undocumented
interfaces should be assumed to be internal.
文档化的接口被认为是公开的，除非文档明确声明它们是临时或内部接口，
不受通常的向后兼容性保证。所有未记录的接口都应该是内部的。 
To better support introspection, modules should explicitly declare the
names in their public API using the ``__all__`` attribute. Setting
``__all__`` to an empty list indicates that the module has no public API.
为了更好地支持内省（introspection），模块应该使用__all__属性
显式地在它们的公共API中声明名称。
将__all__设置为空列表表示模块没有公共API。
Even with ``__all__`` set appropriately, internal interfaces (packages,
modules, classes, functions, attributes or other names) should still be
prefixed with a single leading underscore.
即使通过__all__设置过，内部接口（包，模块，类，方法，属性或其他名字）
依然需要单个下划线前缀。
An interface is also considered internal if any containing namespace
(package, module or class) is considered internal.
如果一个命名空间（包，模块，类）被认为是内部的，那么包含它的接口也
应该被认为是内部的。
Imported names should always be considered an implementation detail.
Other modules must not rely on indirect access to such imported names
unless they are an explicitly documented part of the containing module's
API, such as ``os.path`` or a package's ``__init__`` module that exposes
functionality from submodules.
导入的名称应该始终被视作是一个实现的细节。其他模块必须不能间接访问这样的名称
，除非它是包含它的模块中有明确的文档说明的API，
例如 os.path 或者是一个包里从子模块公开函数接口的 __init__ 模块。

Programming Recommendations 编程建议
===========================

- Code should be written in a way that does not disadvantage other
  implementations of Python (PyPy, Jython, IronPython, Cython, Psyco,
  and such).
  代码应该用不损害其他Python实现的方式去编写
  （PyPy，Jython，IronPython，Cython，Psyco 等）。
  For example, do not rely on CPython's efficient implementation of
  in-place string concatenation for statements in the form ``a += b``
  or ``a = a + b``.  This optimization is fragile even in CPython (it
  only works for some types) and isn't present at all in implementations
  that don't use refcounting.  In performance sensitive parts of the
  library, the ``''.join()`` form should be used instead.  This will
  ensure that concatenation occurs in linear time across various
  implementations.
  比如，不要依赖于在CPython中高效的内置字符连接语句 a += b 或者 a = a + b。
  这种优化甚至在CPython中都是脆弱的（它只适用于某些类型）
  并且没有出现在不使用引用计数的实现中。
  在性能要求比较高的库中，可以种 ”.join() 代替。
  这可以确保字符关联在不同的实现中都可以以线性时间发生。
- Comparisons to singletons like None should always be done with
  ``is`` or ``is not``, never the equality operators.
  和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，
  永远不要用等号运算符。
  Also, beware of writing ``if x`` when you really mean ``if x is not
  None`` -- e.g. when testing whether a variable or argument that
  defaults to None was set to some other value.  The other value might
  have a type (such as a container) that could be false in a boolean
  context!
  另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。
  举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。
  这个其他值应该是在上下文中能成为bool类型false的值。
- Use ``is not`` operator rather than ``not ... is``.  While both
  expressions are functionally identical, the former is more readable
  and preferred.
  使用 is not 运算符，而不是 not … is 。
  虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑。
  Yes::

      if foo is not None:

  No::

      if not foo is None:

- When implementing ordering operations with rich comparisons, it is
  best to implement all six operations (``__eq__``, ``__ne__``,
  ``__lt__``, ``__le__``, ``__gt__``, ``__ge__``) rather than relying
  on other code to only exercise a particular comparison.
  当使用富比较（rich comparisons，一种复杂的对象间比较的新机制，
  （允许返回值不为-1,0,1）实现排序操作的时候，
  最好实现全部的六个操作符（__eq__, __ne__, __lt__, __gt__, __ge__）
  而不是依靠其他的代码去实现特定的比较。
  To minimize the effort involved, the ``functools.total_ordering()``
  decorator provides a tool to generate missing comparison methods.
  为了最大程度减少这一过程的开销， functools.total_ordering() 
  修饰符提供了用于生成缺少的比较方法的工具。
  PEP 207 indicates that reflexivity rules *are* assumed by Python.
  Thus, the interpreter may swap ``y > x`` with ``x < y``, ``y >= x``
  with ``x <= y``, and may swap the arguments of ``x == y`` and ``x !=
  y``.  The ``sort()`` and ``min()`` operations are guaranteed to use
  the ``<`` operator and the ``max()`` function uses the ``>``
  operator.  However, it is best to implement all six operations so
  that confusion doesn't arise in other contexts.
  PEP 207 指出Python实现了反射机制。
  因此，解析器会将 y > x 转变为 x < y，将 y >= x 转变为 x <= y，
  也会转换x == y 和 x != y的参数。
  sort() 和 min()方法确保使用<操作符，max()使用>操作符。
  然而，最好还是实现全部六个操作符，以免在其他地方出现冲突。
- Always use a def statement instead of an assignment statement that binds
  a lambda expression directly to an identifier.
  始终使用def表达式，而不是通过赋值语句将lambda表达式绑定到一个变量上。
  Yes::

      def f(x): return 2*x

  No::

      f = lambda x: 2*x

  The first form means that the name of the resulting function object is
  specifically 'f' instead of the generic '<lambda>'. This is more
  useful for tracebacks and string representations in general. The use
  of the assignment statement eliminates the sole benefit a lambda
  expression can offer over an explicit def statement (i.e. that it can
  be embedded inside a larger expression)
  第一个形式意味着生成的函数对象的名称是“f”而不是泛型“< lambda >”。
  这在回溯和字符串显示的时候更有用。
  赋值语句的使用消除了lambda表达式优于显式def表达式的唯一优势
  （即lambda表达式可以内嵌到更大的表达式中）。
- Derive exceptions from ``Exception`` rather than ``BaseException``.
  Direct inheritance from ``BaseException`` is reserved for exceptions
  where catching them is almost always the wrong thing to do.
  从Exception继承异常，而不是BaseException。
  直接继承BaseException的异常适用于几乎不用来捕捉的异常。 
  Design exception hierarchies based on the distinctions that code
  *catching* the exceptions is likely to need, rather than the locations
  where the exceptions are raised. Aim to answer the question
  "What went wrong?" programmatically, rather than only stating that
  "A problem occurred" (see PEP 3151 for an example of this lesson being
  learned for the builtin exception hierarchy)
  设计异常的等级，要基于扑捉异常代码的需要，而不是异常抛出的位置。
  以编程的方式去回答“出了什么问题？”，而不是只是确认“出现了问题”
  （内置异常结构的例子参考 PEP 3151 ） 
  Class naming conventions apply here, although you should add the
  suffix "Error" to your exception classes if the exception is an
  error.  Non-error exceptions that are used for non-local flow control
  or other forms of signaling need no special suffix.
  类的命名规范适用于这里，但是你需要添加一个“Error”的后缀到你的异常类，
  如果异常是一个Error的话。
  非本地流控制或者其他形式的信号的非错误异常不需要特殊的后缀。
- Use exception chaining appropriately. In Python 3, "raise X from Y"
  should be used to indicate explicit replacement without losing the
  original traceback.
  适当地使用异常链接。在Python 3里，为了不丢失原始的根源，
  可以显式指定“raise X from Y”作为替代。 
  When deliberately replacing an inner exception (using "raise X" in
  Python 2 or "raise X from None" in Python 3.3+), ensure that relevant
  details are transferred to the new exception (such as preserving the
  attribute name when converting KeyError to AttributeError, or
  embedding the text of the original exception in the new exception
  message).
  当故意替换一个内部异常时（Python 2 使用“raise X”， Python 3.3 之后 
  使用 “raise X from None”），确保相关的细节转移到新的异常中
  （比如把AttributeError转为KeyError的时候保留属性名，
  或者将原始异常信息的文本内容内嵌到新的异常中）。
- When raising an exception in Python 2, use ``raise ValueError('message')``
  instead of the older form ``raise ValueError, 'message'``.
  在Python 2中抛出异常时，使用 rasie ValueError(‘message’) 
  而不是用老的形式 raise ValueError, ‘message’。
  The latter form is not legal Python 3 syntax.
  第二种形式在Python3 的语法中不合法 
  The paren-using form also means that when the exception arguments are
  long or include string formatting, you don't need to use line
  continuation characters thanks to the containing parentheses.
  使用小括号，意味着当异常里的参数非常长，或者包含字符串格式化的时候，
  不需要使用换行符。
- When catching exceptions, mention specific exceptions whenever
  possible instead of using a bare ``except:`` clause::
  当捕获到异常时，如果可以的话写上具体的异常名，
  而不是只用一个except:  块。比如说：
      try:
          import platform_specific_module
      except ImportError:
          platform_specific_module = None

  A bare ``except:`` clause will catch SystemExit and
  KeyboardInterrupt exceptions, making it harder to interrupt a
  program with Control-C, and can disguise other problems.  If you
  want to catch all exceptions that signal program errors, use
  ``except Exception:`` (bare except is equivalent to ``except
  BaseException:``).
  如果只有一个except: 块将会捕获到SystemExit和KeyboardInterrupt异常，
  这样会很难通过Control-C中断程序，而且会掩盖掉其他问题。
  如果你想捕获所有指示程序出错的异常，使用 except Exception: 
  （只有except等价于 except BaseException:）。
  A good rule of thumb is to limit use of bare 'except' clauses to two
  cases:
  两种情况不应该只使用‘excpet’块：
  1. If the exception handler will be printing out or logging the
     traceback; at least the user will be aware that an error has
     occurred.
   如果异常处理的代码会打印或者记录log；至少让用户知道发生了一个错误。
  2. If the code needs to do some cleanup work, but then lets the
     exception propagate upwards with ``raise``.  ``try...finally``
     can be a better way to handle this case.
   如果代码需要做清理工作，使用 raise..try…finally 能很好处理这种情况
   并且能让异常继续上浮。
- When binding caught exceptions to a name, prefer the explicit name
  binding syntax added in Python 2.6::
  当给捕捉的异常绑定一个名字时，
  推荐使用在Python 2.6中加入的显式命名绑定语法：
      try:
          process_data()
      except Exception as exc:
          raise DataProcessingFailedError(str(exc))

  This is the only syntax supported in Python 3, and avoids the
  ambiguity problems associated with the older comma-based syntax.
  为了避免和原来基于逗号分隔的语法出现歧义，Python3只支持这一种语法。
- When catching operating system errors, prefer the explicit exception
  hierarchy introduced in Python 3.3 over introspection of ``errno``
  values.
  当捕捉操作系统的错误时，推荐使用Python 3.3 中errno内定数值指定的异常等级。
- Additionally, for all try/except clauses, limit the ``try`` clause
  to the absolute minimum amount of code necessary.  Again, this
  avoids masking bugs.
  另外，对于所有的 try/except 语句块，在try语句中只填充必要的代码，
  这样能避免掩盖掉bug。
  Yes::

      try:
          value = collection[key]
      except KeyError:
          return key_not_found(key)
      else:
          return handle_value(value)

  No::

      try:
          # Too broad!
          return handle_value(collection[key])
      except KeyError:
          # Will also catch KeyError raised by handle_value()
          return key_not_found(key)

- When a resource is local to a particular section of code, use a
  ``with`` statement to ensure it is cleaned up promptly and reliably
  after use. A try/finally statement is also acceptable.
  当代码片段局部使用了某个资源的时候，使用with 表达式来确保
  这个资源使用完后被清理干净。用try/finally也可以。
- Context managers should be invoked through separate functions or methods
  whenever they do something other than acquire and release resources.
  无论何时获取和释放资源，都应该通过单独的函数或方法调用上下文管理器。
  举个例子：
  Yes::

      with conn.begin_transaction():
          do_stuff_in_transaction(conn)

  No::

      with conn:
          do_stuff_in_transaction(conn)

  The latter example doesn't provide any information to indicate that
  the ``__enter__`` and ``__exit__`` methods are doing something other
  than closing the connection after a transaction.  Being explicit is
  important in this case.
  第二个例子没有提供任何信息去指明__enter__和__exit__方法在事务之后
  做出了关闭连接之外的其他事情。这种情况下，明确指明非常重要。
- Be consistent in return statements.  Either all return statements in
  a function should return an expression, or none of them should.  If
  any return statement returns an expression, any return statements
  where no value is returned should explicitly state this as ``return
  None``, and an explicit return statement should be present at the
  end of the function (if reachable).
  返回的语句保持一致。函数中的返回语句都应该返回一个表达式，或者都不返回。
  如果一个返回语句需要返回一个表达式，那么在没有值可以返回的情况下，
  需要用 return None 显式指明，并且在函数的最后显式指定一条返回语句
  （如果能跑到那的话）。
  Yes::

      def foo(x):
          if x >= 0:
              return math.sqrt(x)
          else:
              return None

      def bar(x):
          if x < 0:
              return None
          return math.sqrt(x)

  No::

      def foo(x):
          if x >= 0:
              return math.sqrt(x)

      def bar(x):
          if x < 0:
              return
          return math.sqrt(x)

- Use string methods instead of the string module.
  使用字符串方法代替字符串模块。
  String methods are always much faster and share the same API with
  unicode strings.  Override this rule if backwards compatibility with
  Pythons older than 2.0 is required.
  字符串方法总是更快，并且和unicode字符串分享相同的API。
  如果需要兼容Python2.0之前的版本可以不用考虑这个规则。
- Use ``''.startswith()`` and ``''.endswith()`` instead of string
  slicing to check for prefixes or suffixes.
  使用 ”.startswith() 和 ”.endswith() 代替通过字符串切割的方法去检查前缀和后缀。
  startswith() and endswith() are cleaner and less error prone::
  startswith()和endswith()更干净，出错几率更小。比如：
      Yes: if foo.startswith('bar'):
      No:  if foo[:3] == 'bar':

- Object type comparisons should always use isinstance() instead of
  comparing types directly. ::
  对象类型的比较应该用isinstance()而不是直接比较type。
      Yes: if isinstance(obj, int):

      No:  if type(obj) is type(1):

  When checking if an object is a string, keep in mind that it might
  be a unicode string too!  In Python 2, str and unicode have a
  common base class, basestring, so you can do::
  当检查一个对象是否为string类型时，记住，它也有可能是unicode string！
  在Python2中，str和unicode都有相同的基类：basestring，
  所以你可以这样：
      if isinstance(obj, basestring):

  Note that in Python 3, ``unicode`` and ``basestring`` no longer exist
  (there is only ``str``) and a bytes object is no longer a kind of
  string (it is a sequence of integers instead).
  注意，在Python3中，unicode和basestring都不存在了（只有str）
  并且bytes类型的对象不再是string类型的一种（它是整数序列）
- For sequences, (strings, lists, tuples), use the fact that empty
  sequences are false. ::
  对于序列来说（strings，lists，tuples），可以使用空序列为false的情况。
      Yes: if not seq:
           if seq:

      No:  if len(seq):
           if not len(seq):

- Don't write string literals that rely on significant trailing
  whitespace.  Such trailing whitespace is visually indistinguishable
  and some editors (or more recently, reindent.py) will trim them.
  书写字符串时不要依赖单词结尾的空格，这样的空格在视觉上难以区分，
  有些编辑器会自动去掉他们（比如 reindent.py （译注：re indent 重新缩进））
- Don't compare boolean values to True or False using ``==``. ::
  不要用 == 去和True或者False比较：
      Yes:   if greeting:
      No:    if greeting == True:
      Worse: if greeting is True:


Function Annotations 功能注释
--------------------

With the acceptance of PEP 484, the style rules for function
annotations are changing.
随着PEP 484的引入，功能型注释的风格规范有些变化。
- In order to be forward compatible, function annotations in Python 3
  code should preferably use PEP 484 syntax.  (There are some
  formatting recommendations for annotations in the previous section.)
  为了向前兼容，在Python3代码中的功能注释应该使用 PEP 484的语法规则。
  （在前面的章节中对注释有格式化的建议。）
- The experimentation with annotation styles that was recommended
  previously in this PEP is no longer encouraged.
  不再鼓励使用之前在PEP中推荐的实验性样式。
- However, outside the stdlib, experiments within the rules of PEP 484
  are now encouraged.  For example, marking up a large third party
  library or application with PEP 484 style type annotations,
  reviewing how easy it was to add those annotations, and observing
  whether their presence increases code understandability.
  然而，在stdlib库之外，在PEP 484中的实验性规则是被鼓励的。
  比如用PEP 484的样式标记大型的第三方库或者应用程序，
  回顾添加这些注释是否简单，并观察是否增加了代码的可读性。
- The Python standard library should be conservative in adopting such
  annotations, but their use is allowed for new code and for big
  refactorings.
  Python的标准库代码应该保守使用这种注释，
  但新的代码或者大型的重构可以使用这种注释。
- For code that wants to make a different use of function annotations
  it is recommended to put a comment of the form::
  如果代码希望对功能注释有不同的用途，建议在文件的顶部增加一个这种形式的注释：
      # type: ignore

  near the top of the file; this tells type checker to ignore all
  annotations.  (More fine-grained ways of disabling complaints from
  type checkers can be found in PEP 484.)
  这会告诉检查器忽略所有的注释。
  （在 PEP 484中可以找到从类型检查器禁用投诉的更细粒度的方法。）
- Like linters, type checkers are optional, separate tools.  Python
  interpreters by default should not issue any messages due to type
  checking and should not alter their behavior based on annotations.
  像linters一样，类型检测器是可选的可独立的工具。
  默认情况下，Python解释器不应该因为类型检查而发出任何消息，
  也不应该基于注释改变它们的行为。
- Users who don't want to use type checkers are free to ignore them.
  However, it is expected that users of third party library packages
  may want to run type checkers over those packages.  For this purpose
  PEP 484 recommends the use of stub files: .pyi files that are read
  by the type checker in preference of the corresponding .py files.
  Stub files can be distributed with a library, or separately (with
  the library author's permission) through the typeshed repo [5]_.
  不想使用类型检测的用户可以忽略他们。
  然而，第三方库的用户可能希望在这些库上运行类型检测。
  为此， PEP 484 建议使用存根文件类型：.pyi文件，
  这种文件类型相比于.py文件会被类型检测器读取。
  存根文件可以和库一起，或者通过typeshed repo独立发布（通过库作者的许可）
- For code that needs to be backwards compatible, type annotations
  can be added in the form of comments.  See the relevant section of
  PEP 484 [6]_.
  对于需要向后兼容的代码，可以以注释的形式添加功能型注释。参见PEP 484的相关部分。
  
Variable Annotations 变量注释
--------------------

PEP 526 introduced variable annotations. The style recommendations for them are
similar to those on function annotations described above:
PEP526引入了变量注释。它们的样式建议与上面描述的函数注释类似：
- Annotations for module level variables, class and instance variables,
  and local variables should have a single space after the colon.
  模块级变量、类和实例变量以及局部变量的注释应该在冒号后面有一个空格。
- There should be no space before the colon.
  冒号前不应有空格。
- If an assignment has a right hand side, then the equality sign should have
  exactly one space on both sides.
  如果一个赋值有一个右手边，那么等号两边应该正好各有一个空格。 
- Yes::

      code: int

      class Point:
          coords: Tuple[int, int]
          label: str = '<unknown>'

- No::

      code:int  # No space after colon
      code : int  # Space before colon

      class Test:
          result: int=0  # No spaces around equality sign

- Although the PEP 526 is accepted for Python 3.6, the variable annotation
  syntax is the preferred syntax for stub files on all versions of Python
  (see PEP 484 for details).
  尽管python 3.6接受了PEP 526，但是变量注释语法是所有版本python上
  存根文件的首选语法（有关详细信息，请参阅PEP 484）。